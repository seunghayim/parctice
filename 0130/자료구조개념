# 자료 구조 - 데이터의 효율적인 접근, 조작을 할 수 있게 해주는 방식
# 컴퓨터가 데이터를 저장하는 방식
# 1. 스토리지 - 데이터를 영구적으로 저장하는 곳 / 저장과 불러오기가 비교적 느리다.
# 2. 메모리 - 데이터를 임시로 저장하는 곳 / 저장과 불러오기가 비교적 빠르다.

# 컴퓨터의 메모리 - RAM( Random Access Memory) : 임의 접근 메모리 
#                - 데이터 저장위치를 알면 접근시간이 일정하게 걸린다.- O(1)

# 자료구조 - 즉 메모리에 데이터를 저장하고, 저장된 데이터를 불러온다. 
# 이 때 저장 단위 byte, 메모리 한 칸에 담기는 용량: 1byte


# 파이썬 vs c 배열
# c 배열 : 크키 고정 / 같은 타입 데이터만 저장가능 순서대로 ex) int save[4]; 시작주소 + 4(byte) * i - O(1
# 파이썬 : 레퍼런스를 저장 이 래퍼런스가 값들을 가르킨다. 즉 여러 타입의 데이터를 담을 수 있다.

# 접근 / 탐색
# 접근 - 인덱스를 통하여 값을 찾는다. O(1)
# 탐색 - 특정 조건을 만족하는 값을 찾는다. O(n)

# 배열
# 정적 배열 : 크기 고정
# 동적 배열 : 크기 변함(정적 배열을 기반으로 하여, 필요할때 늘린다.) O(1) ~ O(n) (내부적으로 정적배열을 이용하여 늘리거나 줄인다.)
# 분할 상환 분석 - 같은 동작을 n 번 했을때 드는 시간X 에 대하여 도작 한 번에 걸리는 시간 X/n
# 동적 배열의 추가 연산은 최악의 경우 O(n)이 걸리지만, 분할 상환 분석을 하면 O(1)이 걸린다.

# 삽입(정적 배열은 불가능)
# 삽입 연산 시간 : O(n)

# 삭제(정적 배열은 깔끔하게 불가능 2,3,4,5 -> 2,3,4,4 이때 동적 배열은 접근 가능 인덱스를 제한하여 삭제효과를 준다.)
# O(1) ~ O(n) / 맨뒤 / 맨앞 (배열의 크기가 줄어들 수도 있으므로)
# 동적 배열에서 맨 끝 데이터를 삭제하는 연산은 최악의 경우 O(n)
# 분할 상환 분석을 적용하면 O(1)이라고 할 수 있다.

# 낭비되는 공간
# 공간이 부족해 배열을 만들 었을 떄 O(n)-2 ~> O(n)
